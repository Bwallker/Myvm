import dynamic from 'next/dynamic';
import { ReactNode } from 'react';
import { WasmSuccessfulParse } from '../../pkg/index';

type ParseResult = ParseErr | ParseOk;

interface ParseOk {
	wasSuccessful: true;
	parsed: WasmSuccessfulParse;
}

interface ParseErr {
	wasSuccessful: false;
	error: string;
}

const ParseInput = (props: { input: ParseResult }): JSX.Element => {
	if (!props.input.wasSuccessful) {
		return (
			<div>
				<h1>Your input could not be parsed! Here is the error!</h1>
				<p>{props.input.error}</p>
			</div>
		);
	} else {
		const formattedProgram: ReactNode[] = new Array(
			props.input.parsed.get_program().length,
		);
		let i = 0;
		for (const x of props.input.parsed.get_program()) {
			formattedProgram.push(<p key={i++}>{x + ''}</p>);
		}

		const formattedInput: ReactNode[] = new Array(
			props.input.parsed.get_input().length,
		);
		i = 0;
		for (const x of props.input.parsed.get_input()) {
			formattedInput.push(<p key={i++}>{x + ''}</p>);
		}
		i = 0;
		return (
			<div>
				<h1 className='py-5 my-5'>Here is the generated bytecode!</h1>
				<div>{formattedProgram}</div>
				<h1 className='py-5 my-5'>Here is the generated input!</h1>
				<div>{formattedInput}</div>
				<h1>Here is what your program looked like after macro expansion!</h1>
				<div className='py-5 my-5'>
					{props.input.parsed
						.get_expanded()
						.split('\n')
						.map((x) => i++ !== -1 && <p key={i}>{x}</p>)}
				</div>
			</div>
		);
	}
};

const RustComponent = dynamic({
	loader: async () => {
		// Import the wasm module
		const rustModule = await import('../../pkg/index');

		// Return a React component that calls the add_one method on the wasm module
		// eslint-disable-next-line react/display-name
		return (props: { input: string }) => {
			let toParse: ParseResult;
			try {
				const res = rustModule.parse_wasm_edition(props.input);
				toParse = {
					wasSuccessful: true,
					parsed: res,
				};
			} catch (e) {
				toParse = {
					wasSuccessful: false,
					error: e + '',
				};
			}

			return <ParseInput input={toParse} />;
		};
	},
	ssr: false,
});

export default RustComponent;
