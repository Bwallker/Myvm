import dynamic from 'next/dynamic';
import { ReactNode } from 'react';
import { WasmSuccessfulParse } from '../../pkg/index';
import MyvmEditor from '../components/MyvmEditor';
import Collapsible from 'react-collapsible';

type ParseResult = ParseErr | ParseOk;

interface ParseOk {
	wasSuccessful: true;
	parsed: WasmSuccessfulParse;
}

interface ParseErr {
	wasSuccessful: false;
	error: string;
}

const decimalToHex = (d: number, padding: number) => {
	let hex = d.toString(16);

	while (hex.length < padding) {
		hex = '0' + hex;
	}

	return '0x' + hex;
};

const ParseInput = (props: { input: ParseResult }): JSX.Element => {
	if (!props.input.wasSuccessful) {
		return (
			<div>
				<h1>Your input could not be parsed! Here is the error!</h1>
				<p>{props.input.error}</p>
			</div>
		);
	} else {
		const formattedProgram: ReactNode[] = new Array(
			props.input.parsed.get_program().length,
		);
		let i = 0;
		for (const x of props.input.parsed.get_program()) {
			formattedProgram.push(
				<p className='p-0 m-0' key={i++}>
					{decimalToHex(x, 2)}
				</p>,
			);
		}

		const formattedInput: ReactNode[] = new Array(
			props.input.parsed.get_input().length,
		);
		i = 0;
		for (const x of props.input.parsed.get_input()) {
			formattedInput.push(
				<p className='p-0 m-0' key={i++}>
					{decimalToHex(x, 2)}
				</p>,
			);
		}
		i = 0;
		return (
			<div>
				<Collapsible
					trigger={'Generated bytecode: (Click me to expand!)'}
					triggerWhenOpen={'Generated bytecode: (Click me to close!)'}
				>
					<div>{formattedProgram}</div>
				</Collapsible>
				<Collapsible
					trigger={'Generated input: (Click me to expand!)'}
					triggerWhenOpen={'Generated input: (Click me to close!)'}
				>
					<div>{formattedInput}</div>
				</Collapsible>
				<Collapsible
					trigger={'Expanded macros: (Click me to expand!)'}
					triggerWhenOpen={'Expanded macros: (Click me to close!)'}
				>
					<MyvmEditor
						readonly={true}
						initialValue={props.input.parsed.get_expanded()}
						height={0.5}
						width={0.5}
					/>
				</Collapsible>
			</div>
		);
	}
};

const Parse = dynamic({
	loader: async () => {
		// Import the wasm module
		const rustModule = await import('../../pkg/index');

		// Return a React component that calls the add_one method on the wasm module
		// eslint-disable-next-line react/display-name
		return (props: { input: string }) => {
			let toParse: ParseResult;
			try {
				const res = rustModule.parse_wasm_edition(props.input);
				toParse = {
					wasSuccessful: true,
					parsed: res,
				};
			} catch (e) {
				toParse = {
					wasSuccessful: false,
					error: e + '',
				};
			}

			return <ParseInput input={toParse} />;
		};
	},
	ssr: false,
});

export default Parse;
