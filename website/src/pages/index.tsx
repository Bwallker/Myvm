import type { NextPage } from 'next';
import MyvmEditor from './MyvmEditor';
import { ReactNode, useState } from 'react';
import parse from '../util/parse';

const Home: NextPage = () => {
	const [contents, setContents] = useState('');
	return (
		<div className='row row-cols-2'>
			<MyvmEditor
				className='w-100 h-100'
				onChange={(s) => {
					if (s !== undefined) {
						setContents(s);
					}
				}}
			/>
			<div className='row row-cols-2'>{parseInput(contents)}</div>
		</div>
	);
};

const parseInput = (input: string): ReactNode => {
	const res = parse(input);
	if (!res.wasSuccessful) {
		return (
			<div>
				<h1>Your input could not be parsed! Here is the error!</h1>
				<p>{res.error}</p>
			</div>
		);
	} else {
		const formattedProgram: ReactNode[] = new Array(
			res.parsed.get_program().length,
		);
		for (const x of res.parsed.get_program()) {
			formattedProgram.push(<p>{x + ''}</p>);
		}

		const formattedInput: ReactNode[] = new Array(
			res.parsed.get_input().length,
		);
		for (const x of res.parsed.get_input()) {
			formattedInput.push(<p>{x + ''}</p>);
		}
		return (
			<div>
				<h1>Here is the generated bytecode!</h1>
				<p>{formattedProgram}</p>
				<h1>Here is the generated input!</h1>
				<p>{formattedInput}</p>
				<h1>Here is what your program looked like after macro expansion!</h1>
				<p>
					{res.parsed
						.get_expanded()
						.split('\n')
						.map((x) => (
							<p>{x}</p>
						))}
				</p>
			</div>
		);
	}
};

export default Home;
