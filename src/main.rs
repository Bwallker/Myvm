#![allow(clippy::unusual_byte_groupings)]

extern crate core;

use std::fs::File;
use std::io::{stdin, stdout, Read, Write};
use std::path::PathBuf;

use clap::{Args, Parser, Subcommand};
use color_eyre::eyre::{eyre, Result};

use assembler::parser::parse;
use bytecode_interpreter::run::{interpret, Input, Output};

mod bytecode_interpreter;

mod assembler;

#[derive(Parser)]
#[clap(author, version, about, long_about = None)]
struct Cli {
    #[clap(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    #[clap(alias = "r")]
    Run(Run),
    #[clap(alias = "ar")]
    AssembleAndRun(AssembleAndRun),
    #[clap(alias = "a")]
    Assemble(Assemble),
}
#[derive(Args)]
struct Run {
    /// The path to the program to execute
    #[clap(short, long, parse(from_os_str), value_name = "PROGRAM_FILE")]
    program_path: PathBuf,
    /// The path to the file the program should get its input from.
    ///
    ///If no file is specified the input get read from STDIN.
    ///
    /// If you are
    #[clap(short, long, parse(from_os_str), value_name = "INPUT_FILE")]
    input_path: Option<PathBuf>,
    /// The path to the file the program output should be put into.
    ///
    /// If no file is specified the output gets dumped to STDOUT.
    #[clap(short, long, parse(from_os_str), value_name = "OUTPUT_FILE")]
    output_path: Option<PathBuf>,
}

#[derive(Args)]
struct AssembleAndRun {
    /// The path to the source code to be assembled.
    #[clap(short, long, parse(from_os_str), value_name = "SOURCE_FILE")]
    source_path: PathBuf,
    /// The path to the file the program output should be put into.
    ///
    /// If no file is specified the output gets dumped to STDOUT.
    #[clap(short, long, parse(from_os_str), value_name = "OUTPUT_FILE")]
    output_path: Option<PathBuf>,
    /// If use_stdin is set, then the program will use STDIN for its input instead of the input inside the assembly file.
    #[clap(short, long)]
    use_stdin: bool,
}

#[derive(Args)]
struct Assemble {
    /// The path to the source code to be assembled.
    #[clap(short, long, parse(from_os_str), value_name = "SOURCE_FILE")]
    source_path: PathBuf,
    /// The path to the file into which the generated bytecode should go.
    #[clap(
        short = 'p',
        long,
        parse(from_os_str),
        value_name = "GENERATED_PROGRAM_FILE"
    )]
    generated_program_path: PathBuf,
    /// The path to the file into which the generated program input should go. If no input path is specified, then the generated input will be ignored.
    #[clap(
        short = 'i',
        long,
        parse(from_os_str),
        value_name = "GENERATED_INPUT_FILE"
    )]
    generated_input_path: Option<PathBuf>,
}

fn main() -> Result<()> {
    color_eyre::install()?;
    let args: Cli = Cli::parse();
    match args.command {
        Commands::Run(r) => run(r),
        Commands::Assemble(a) => assemble(a),
        Commands::AssembleAndRun(ar) => assemble_and_run(ar),
    }
}

fn run(args: Run) -> Result<()> {
    let input = handle_input(args.input_path)?;
    let program = handle_program(args.program_path)?;
    let output = handle_output(args.output_path)?;

    interpret(&program, input, output)?;

    Ok(())
}

fn assemble(args: Assemble) -> Result<()> {
    let source = handle_source(args.source_path)?;
    let ast = parse(&source)?;
    let (input, program) = (ast.input, ast.program);
    let mut program_file = File::create(args.generated_program_path)?;
    program_file.write_all(&program)?;
    if let Some(input_path) = args.generated_input_path {
        let mut input_file = File::create(input_path)?;
        input_file.write_all(&input)?;
    }
    Ok(())
}

fn assemble_and_run(args: AssembleAndRun) -> Result<()> {
    let source = handle_source(args.source_path)?;
    let ast = parse(&source)?;
    let (input_vec, program_vec) = (ast.input, ast.program);
    let input = if args.use_stdin {
        Input::STDIN(stdin())
    } else {
        Input::ARRAY(&input_vec)
    };
    let output = handle_output(args.output_path)?;
    interpret(&program_vec, input, output)?;
    Ok(())
}

fn handle_input<'a>(input: Option<PathBuf>) -> Result<Input<'a>> {
    match input {
        None => Ok(Input::STDIN(stdin())),
        Some(v) => Ok(Input::FILE(match File::open(v) {
            Ok(v) => v,
            Err(e) => return Err(eyre!("Failed at opening the input file you provided. This is most likely because the path you provided was bad. Here is the precise error: {e}")),
        })),
    }
}

fn handle_output<'a>(output: Option<PathBuf>) -> Result<Output<'a>> {
    match output {
        None => {
            Ok(Output::STDOUT(stdout()))
        }
        Some(v) => {
            Ok(Output::FILE(match File::create(v) {
                Ok(x) => x,
                Err(e) => return Err(eyre!("Failed at creating the output file you provided. This is most likely because the path you provided is bad. Here is the precise error: {e}"))
            }))
        }
    }
}

fn handle_program(program_path: PathBuf) -> Result<Vec<u8>> {
    let mut program_file = match File::open(program_path) {
        Ok(v) => v,
        Err(e) => return Err(eyre!("Failed at opening the program file you provided. This is most likely because the path you provided was bad. Here is the precise error: {e}")),
    };
    let mut program_buf = Vec::new();
    let _ = program_file.read_to_end(&mut program_buf)?;
    Ok(program_buf)
}

fn handle_source(source_path: PathBuf) -> Result<String> {
    println!("{source_path:?}");
    let mut source_file = match File::open(source_path) {
        Ok(v) => v,
        Err(e) => {
            return Err(
                eyre!("Failed at opening the source file you provided. This is most likely because the path you provided was bad. Here is the precise error: {e}"),
            )
        }
    };
    let mut s = String::new();
    let _ = source_file.read_to_string(&mut s)?;
    Ok(s)
}
